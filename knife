#!/usr/bin/env python3

import json
import os
import re
import requests
import shutil
import stat
import sys
import tarfile

USER_HOME = os.environ.get("HOME")
KNIFE_HOME = f"{USER_HOME}/knife"

SUB_MSG_PREFIX = " - "


def read_manifest(app_name):
    manifest = f"{KNIFE_HOME}/manifests/{app_name}.json"
    info = None
    try:
        with open(manifest, "r") as json_file:
            info = json.load(json_file)
            info["_"] = {
                "manifest_file": manifest,
                "cache_path"   : f"{KNIFE_HOME}/cache/{app_name}-{info['version']}.{info['dl_type']}",
                "version_dir"  : f"{KNIFE_HOME}/apps/{app_name}/{info['version']}",
                "current_dir"  : f"{KNIFE_HOME}/apps/{app_name}/current",
            }
    except FileNotFoundError:
        raise FileNotFoundError(f"File '{manifest}' not found!")
    except json.JSONDecodeError:
        raise ValueError(f"Invalid JSON data in '{manifest}'!")

    return info


def download_from_url(url, out_filename):
    response = requests.get(url, stream=True)
    response.raise_for_status()

    with open(out_filename, "wb") as f:
        for chunk in response.iter_content(1024):
            f.write(chunk)

    # TODO: error handling


def extract_tar(tar_file, tar_type, dest_path):
    match tar_type:
        case "tar.gz":
            open_type = "r:gz"
        case _:
            raise ValueError(f"Unsupported tar type '{tar_type}'!")

    with tarfile.open(tar_file, open_type) as tar:
        tar.extractall(dest_path)

    # TODO: error handling


def copy_all_files(src_path, dest_path):
    if not os.path.exists(dest_path):
        os.makedirs(dest_path)

    for filename in os.listdir(src_path):
        src = os.path.join(src_path, filename)
        dest = os.path.join(dest_path, filename)

        if os.path.isfile(src):
            shutil.copy2(src, dest)
        elif os.path.isdir(src):
            copy_all_files(src, dest)


def create_symlink(target_full_path, link_path, unsafe_target_short_path=None):
    if not os.path.exists(target_full_path):
        raise ValueError(f"Path not found: '{target_full_path}'!")
    if os.path.exists(link_path):
        os.unlink(link_path)

    if unsafe_target_short_path != None:
        target_full_path = unsafe_target_short_path
    os.symlink(target_full_path, link_path)


def chmod_user_executable(path):
    current_stat = os.stat(path)
    current_permissions = current_stat.st_mode
    new_permissions = current_permissions | stat.S_IXUSR
    os.chmod(path, new_permissions)

    # TODO: error handling


def refresh_manifest(app_name, info=None):
    if info == None:
        info = read_manifest(app_name)
    url = info["checkver"]["url"]
    regex = info["checkver"]["regex"]
    match = info["checkver"]["match"].copy() if "match" in info["checkver"] else {}
    autoupdate = info["autoupdate"]

    if not "version" in match:
        match["version"] = "$1"

    response = requests.get(url)
    response.raise_for_status()

    matches = re.search(regex, response.text)

    l = len(matches.groups())
    local_var = {}
    for var, pattern in match.items():
        for i in range(l):
            pattern = pattern.replace(f"${i+1}", matches.group(i+1))
        local_var[var] = pattern

    new_keys = {}
    new_keys["version"] = local_var["version"]
    if info["version"] == new_keys["version"]:
        return False

    new_keys["url"] = autoupdate["url"]
    for k, v in local_var.items():
        new_keys["url"] = new_keys["url"].replace(f"${k}", v)

    new_keys["bin"] = []
    if "bin" in autoupdate:
        for e in autoupdate["bin"]:
            e = e.copy()
            for k, v in local_var.items():
                e[0] = e[0].replace(f"${k}", v)
                e[1] = e[1].replace(f"${k}", v)
            new_keys["bin"].append(e)
    else:
        new_keys["bin"] = info["bin"]


    new_info = {}
    for k, v in info.items():
        if k in new_keys:
            new_info[k] = new_keys[k]
        elif k == "_":
            continue
        else:
            new_info[k] = v

    with open(info["_"]["manifest_file"], "w") as outfile:
        json.dump(new_info, outfile, indent=2)

    return True

    # TODO: error handling


def check_argc(argc, sub_command, sub_command_need=1):
    if argc < sub_command_need + 2:
        raise ValueError(f"Please provide {sub_command_need} argument(s) for '{sub_command}'!")


def cmd_info(app_name, info=None):
    if info == None:
        info = read_manifest(app_name)
    bin = ", ".join([e[1] for e in info["bin"]])
    print(f"""
app     : {app_name}
version : {info["version"]}
url     : {info["url"]}
bin     : {bin}
""")


def cmd_download(app_name, info=None, msg_prefix=""):
    if info == None:
        info = read_manifest(app_name)
    print(f"{msg_prefix}Downloading {app_name}@{info['version']}")

    if info["dl_type"] == "plain":
        if os.path.exists(info["_"]["cache_path"]):
            shutil.rmtree(info["_"]["cache_path"])
        os.mkdir(info["_"]["cache_path"])
        download_from_url(info["url"], info["_"]["cache_path"] + "/" + os.path.basename(info["url"]))
    else:
        download_from_url(info["url"], info["_"]["cache_path"])

    print(f"{msg_prefix}Download successful")


def cmd_extract(app_name, info=None, msg_prefix=""):
    if info == None:
        info = read_manifest(app_name)
    print(f"{msg_prefix}Extracting {app_name}")

    if info["dl_type"] == "plain":
        copy_all_files(info["_"]["cache_path"], info["_"]["version_dir"])
    else:
        extract_tar(info["_"]["cache_path"], info["dl_type"], info["_"]["version_dir"])

    print(f"{msg_prefix}Extract successful")


def cmd_reset(app_name, info=None, msg_prefix=""):
    if info == None:
        info = read_manifest(app_name)
    print(f"{msg_prefix}Linking current version to {app_name}@{info['version']}")
    create_symlink(info["_"]["version_dir"], info["_"]["current_dir"], info["version"])
    print(f"{msg_prefix}Link successful")

    for bin_pair in info["bin"]:
        print(f"{msg_prefix}Creating shim '{bin_pair[1]}' for executable '{bin_pair[0]}'")
        # TODO: check overwrite
        chmod_user_executable(f"{info['_']['current_dir']}/{bin_pair[0]}")
        create_symlink(
            f"{info['_']['current_dir']}/{bin_pair[0]}",
            f"{KNIFE_HOME}/shims/{bin_pair[1]}",
            f"../apps/{app_name}/current/{bin_pair[0]}"
        )
        print(f"{msg_prefix}Create successful")


def cmd_install(app_name, info=None):
    if info == None:
        info = read_manifest(app_name)

    if info["version"] == "":
        cmd_update(app_name, info)
        return

    print(f"Installing {app_name}@{info['version']} ...")
    if os.path.exists(info["_"]["cache_path"]):
        print(f"{SUB_MSG_PREFIX}Found existing cache")
    else:
        cmd_download(app_name, info, SUB_MSG_PREFIX)

    # TODO: check cache_path again

    cmd_extract(app_name, info, SUB_MSG_PREFIX)
    cmd_reset(app_name, info, SUB_MSG_PREFIX)


def cmd_update(app_name, info=None, no_install=False):
    if info == None:
        info = read_manifest(app_name)
    print(f"Refreshing {app_name}'s manifest ...")

    print(f"{SUB_MSG_PREFIX}Checking new version")
    if refresh_manifest(app_name, info):
        old_version = info["version"]
        info = read_manifest(app_name)
        print(f"{SUB_MSG_PREFIX}Found update: {old_version} -> {info['version']}")
        if not no_install:
            cmd_install(app_name, info)
    else:
        print(f"{SUB_MSG_PREFIX}No update. Current version: {info['version']}")


def cmd_uninstall(app_name, info=None):
    if info == None:
        info = read_manifest(app_name)
    print(f"Uninstalling {app_name} ...")

    for bin_pair in info["bin"]:
        print(f"{SUB_MSG_PREFIX}Removing shim '{bin_pair[1]}'")
        os.unlink(f"{KNIFE_HOME}/shims/{bin_pair[1]}")
        print(f"{SUB_MSG_PREFIX}Remove successful")


if __name__ == "__main__":
    argv = sys.argv
    argc = len(argv)

    if argc >= 2:
        match argv[1]:
            case "info":
                check_argc(argc, "info")
                cmd_info(argv[2])
            case "download":
                check_argc(argc, "download")
                cmd_download(argv[2])
            case "extract":
                check_argc(argc, "extract")
                cmd_extract(argv[2])
            case "reset":
                check_argc(argc, "reset")
                cmd_reset(argv[2])
            case "install":
                check_argc(argc, "install")
                cmd_install(argv[2])
            case "update":
                check_argc(argc, "update")
                cmd_update(argv[2])
            case "refresh":
                check_argc(argc, "refresh")
                cmd_update(argv[2], no_install=True)
            case "uninstall":
                check_argc(argc, "uninstall")
                cmd_uninstall(argv[2])
            case _:
                raise ValueError(f"Unsupported sub command '{argv[1]}'!")
